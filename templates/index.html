<!doctype html>
<html lang="ko">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>PDF 병합/분할</title>
		<style>
			body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple SD Gothic Neo', 'Malgun Gothic', sans-serif; margin: 24px; }
			.container { max-width: 860px; margin: 0 auto; }
			.card { border: 1px solid #ddd; border-radius: 10px; padding: 16px; margin-bottom: 20px; }
			h2 { margin: 0 0 12px; font-size: 20px; }
			.row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
			label { font-weight: 600; }
			input[type="text"] { padding: 6px 10px; }
			input[type="file"] { padding: 6px 0; }
			button { background: #2563eb; color: white; border: none; padding: 8px 14px; border-radius: 8px; cursor: pointer; }
			button:hover { background: #1d4ed8; }
			.help { color: #555; font-size: 12px; }
		</style>
	</head>
	<body>
		<div class="container">
			<h1>PDF 병합/분할</h1>
			<p class="help">간단한 웹 UI로 PDF를 병합하거나 분할합니다.</p>

			<div class="card">
				<h2>병합</h2>
				<form id="merge-form" action="/merge" method="post" enctype="multipart/form-data" onsubmit="return submitMergeOrdered(event)">
					<div class="row" style="align-items:flex-start; gap:20px;">
						<div>
							<label for="merge-file-input">PDF 파일 추가</label>
							<input id="merge-file-input" type="file" accept="application/pdf,.pdf" multiple />
							<p class="help">아래 목록에서 순서를 드래그해 조정하세요.</p>
						</div>
						<div style="flex:1; min-width:240px;">
							<ol id="merge-ordered-list" style="margin:0; padding-left:20px;"></ol>
						</div>
					</div>
					<div class="row">
						<label for="merge-name">출력 파일명</label>
						<input id="merge-name" type="text" name="output_name" placeholder="merged.pdf" />
					</div>
					<div class="row" style="gap:8px;">
						<button type="submit">병합 실행</button>
						<button type="button" onclick="clearMergeList()" style="background:#6b7280;">초기화</button>
					</div>
					<p class="help">2개 이상 추가 후 순서를 조정하면, 그 순서대로 병합됩니다.</p>
				</form>
			</div>

			<div class="card">
				<h2>분할</h2>
				<form action="/split" method="post" enctype="multipart/form-data">
					<div class="row">
						<label for="split-file">PDF 파일</label>
						<input id="split-file" type="file" name="file" accept="application/pdf,.pdf" required />
					</div>
					<div class="row">
						<label for="split-ranges">범위(선택)</label>
						<input id="split-ranges" type="text" name="ranges" placeholder="예: 1-3,5,7-" />
					</div>
					<div class="row">
						<button type="submit">분할 실행</button>
					</div>
					<p class="help">범위를 비우면 각 페이지를 개별 PDF로 생성합니다.</p>
				</form>
			</div>
		</div>

	<script>
	// 한글 주석: 병합 파일 순서를 사용자가 직접 관리할 수 있도록, 파일 입력과 별도의 정렬 가능한 리스트를 제공합니다.
	const mergeFileInput = document.getElementById('merge-file-input');
	const mergeOrderedList = document.getElementById('merge-ordered-list');

	/**
	 * 선택된 파일들을 내부 메모리에 보관하고, DOM 리스트에 표시합니다.
	 * 같은 파일명을 여러 번 추가하면 뒤에 번호를 붙여 구분합니다.
	 */
	let mergeFilesStore = [];

	function addFilesToList(fileList) {
		for (const file of fileList) {
			const displayName = generateUniqueDisplayName(file.name);
			mergeFilesStore.push({ file, displayName });
			appendListItem(displayName);
		}
		refreshListIndices();
	}

	function generateUniqueDisplayName(name) {
		const base = name;
		let idx = 1;
		let candidate = base;
		const existing = new Set(mergeFilesStore.map(x => x.displayName));
		while (existing.has(candidate)) {
			const dot = base.lastIndexOf('.');
			if (dot > 0) candidate = base.slice(0, dot) + ` (${idx})` + base.slice(dot);
			else candidate = base + ` (${idx})`;
			idx += 1;
		}
		return candidate;
	}

	function appendListItem(displayName) {
		const li = document.createElement('li');
		li.draggable = true;
		li.textContent = displayName;
		li.style.cursor = 'move';
		li.style.userSelect = 'none';
		li.dataset.displayName = displayName;
		// 삭제 버튼
		const del = document.createElement('button');
		del.type = 'button';
		del.textContent = '삭제';
		del.style.marginLeft = '8px';
		del.style.background = '#ef4444';
		del.onclick = () => removeListItem(displayName);
		li.appendChild(del);
		// 드래그 앤 드롭 이벤트
		li.addEventListener('dragstart', onDragStart);
		li.addEventListener('dragover', onDragOver);
		li.addEventListener('drop', onDrop);
		mergeOrderedList.appendChild(li);
	}

	function removeListItem(displayName) {
		mergeFilesStore = mergeFilesStore.filter(x => x.displayName !== displayName);
		for (const li of Array.from(mergeOrderedList.children)) {
			if (li.dataset.displayName === displayName) li.remove();
		}
		refreshListIndices();
	}

	function refreshListIndices() {
		let i = 1;
		for (const li of Array.from(mergeOrderedList.children)) {
			li.dataset.order = String(i++);
		}
	}

	let dragSrc = null;
	function onDragStart(e) { dragSrc = this; e.dataTransfer.effectAllowed = 'move'; }
	function onDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }
	function onDrop(e) {
		e.preventDefault();
		if (!dragSrc || dragSrc === this) return;
		const children = Array.from(mergeOrderedList.children);
		const srcIdx = children.indexOf(dragSrc);
		const dstIdx = children.indexOf(this);
		if (srcIdx < 0 || dstIdx < 0) return;
		if (srcIdx < dstIdx) mergeOrderedList.insertBefore(dragSrc, this.nextSibling);
		else mergeOrderedList.insertBefore(dragSrc, this);
		// 내부 스토어도 동일하게 순서 재정렬
		const orderNames = Array.from(mergeOrderedList.children).map(li => li.dataset.displayName);
		mergeFilesStore.sort((a, b) => orderNames.indexOf(a.displayName) - orderNames.indexOf(b.displayName));
		refreshListIndices();
	}

	mergeFileInput.addEventListener('change', (e) => {
		const files = e.target.files;
		if (files && files.length > 0) addFilesToList(files);
		// 입력 초기화로 같은 파일 재선택 허용
		e.target.value = '';
	});

	function clearMergeList() {
		mergeFilesStore = [];
		mergeOrderedList.innerHTML = '';
	}

	function submitMergeOrdered(ev) {
		ev.preventDefault();
		if (mergeFilesStore.length < 2) { alert('최소 2개 파일을 추가하세요.'); return false; }
		const form = ev.target;
		const fd = new FormData();
		const outputName = document.getElementById('merge-name').value || 'merged.pdf';
		fd.set('output_name', outputName);
		for (const item of mergeFilesStore) {
			fd.append('files', item.file, item.file.name);
		}
		fetch(form.action, { method: 'POST', body: fd })
			.then(async (res) => {
				if (!res.ok) { const t = await res.text(); throw new Error(t || ('HTTP ' + res.status)); }
				const disp = res.headers.get('Content-Disposition') || '';
				const match = /filename="?([^";]+)"?/i.exec(disp);
				const filename = match ? match[1] : outputName;
				const blob = await res.blob();
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
				URL.revokeObjectURL(url);
			})
			.catch((err) => { alert('병합 실패: ' + err.message); });
		return false;
	}
	</script>
	</body>
</html>
